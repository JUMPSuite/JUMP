#!/bin/env perl

use strict;
use warnings;
use Cwd;
use File::Basename;
use FindBin qw($Bin);
use lib "$Bin";

## Directory information
my $currDir = getcwd()."/ParameterFiles";
if (!-e $currDir) {
	system ("mkdir $currDir");
}

## Version information
my $version = "1.13.0";
my $releaseDate = "11/01/2017";

## Search engines/Conditions
my @searchEngines = ("JUMP", "COMET", "SEQUEST");
my @conditions  = ("HH", "HL", "TMThh", "TMThhpho", "TMTpro", "TMTpro_pho");

##################################################
## Search parameter file generation (jump -s)	##
##################################################
foreach my $searchEngine (@searchEngines) {
	foreach my $condition (@conditions) {

		next if (lc($searchEngine) eq "sequest" && ($condition eq "TMTpro" || $condition eq "TMTpro_pho"));
		
		##############################################################
		## Search engine- and condition-dependent parameter setting	##
		##############################################################
		my $databaseName;
		my $pitFile;
		my $isolationWindow = 1.6;
		my $isolationOffset = 0.25;
		my $isolationVariation = 0.25;
		my $percentagePPI = 10;
		my $massCorrection = 2;
		my $ms2Deisotope = 1;
		my $ms2Consolidation = 10;
		my $TMTdata = 0;
		my $tagGeneration = 0;
		my $tagTolerance = 10;
		my $tagToleranceUnit = 2;
		my $ionSeries = "1 1 0 0 0 0 0 1 0";
		my $fragMassTolerance;
		my $fragMassToleranceUnit;
		my $ionLossesMS2 = "0 0 0 0";
		my $ionLossesMS1 = 0;
		my $secondSearch = 0;
		my $addNtermPeptide = "0.0000";
		my $addKLysine = "0.0000";
		my ($dynamicS, $dynamicT, $dynamicY);
		my $paramsDir;
		my $paramsName;
		## Database name and pit file
		my $apps_path;
		if ($searchEngine eq "JUMP"|| $searchEngine eq "COMET") {
			$apps_path = "/hpcf/authorized_apps/proteomics_apps";
		} else {
			$apps_path = "/data1";
		}
		if ($searchEngine eq "JUMP" || $searchEngine eq "COMET") {
			if ($condition eq "HH" || $condition eq "HL") {
				$databaseName = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57.fasta.mdx";
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57.pit";
			} elsif ($condition eq "TMThh") {
				$databaseName = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_TMT_K229.fasta.mdx";
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_TMT_K229.pit";
			} elsif ($condition eq "TMThhpho") {
				$databaseName = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_pho_TMT_K229.fasta.mdx";
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_pho_TMT_K229.pit";
			} elsif ($condition eq "TMTpro") {
				$databaseName = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_TMTpro.fasta.mdx";
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_TMTpro.pit";
			} elsif ($condition eq "TMTpro_pho") {
				$databaseName = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_pho_TMTpro.fasta.mdx";
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_pho_TMTpro.pit";
			}
		} else {
			if ($condition eq "HH" || $condition eq "HL") {
				$databaseName = $apps_path."/database/20150201/human_ft_mc2_c57.fasta.hdr";
				$pitFile = $apps_path."/database/20150201/human_ft_mc2_c57.pit";
			} elsif ($condition eq "TMThh") {
				$databaseName = $apps_path."/database/20150201/human_ft_mc2_c57_TMT_K229.fasta.hdr";
				$pitFile = $apps_path."/database/20150201/human_ft_mc2_c57_TMT_K229.pit";
			} elsif ($condition eq "TMThhpho") {
				$databaseName = $apps_path."/database/20150201/human_ft_mc2_c57_TMT_K229.fasta.hdr";
				$pitFile = $apps_path."/database/20150201/human_ft_mc2_c57_TMT_K229.pit";
			}
		}
		## Isolation window
		if ($condition eq "TMThh" || $condition eq "TMTpro") {
			$isolationWindow = 1.0;
			$isolationOffset = 0.2;
			$isolationVariation = 0.2;
		} elsif ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$isolationWindow = 1.4;
			$isolationOffset = 0;
			$isolationVariation = 0.2;
		}
		## PPI percentage
		if ($condition eq "TMThh" || $condition eq "TMThhpho" || $condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			$percentagePPI = 50;
		}
		## Mass correction and MS2-deisotope
		if ($condition eq "HL") {
			$massCorrection = 1;
			$ms2Deisotope = 0;
		}
		## MS2-consolidation
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$ms2Consolidation = 20;
		} elsif ($searchEngine eq "SEQUEST" && $condition eq "HL") {
			$ms2Consolidation = 20;
		}
		## SEQUEST-phospho-search
		if ($searchEngine eq "SEQUEST" && ($condition eq "TMThhpho" || $condition eq "TMTpro_pho")) {
			$ms2Deisotope = 0;
			$ms2Consolidation = 10000;
		}
		## TMT-data
		if ($condition eq "TMThh" || $condition eq "TMThhpho" || $condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			$TMTdata = 1;
		}
		## Tag generation
		if ($searchEngine eq "JUMP") {
			$tagGeneration = 1;
		}
		## Tag tolerance and ion series
		if ($condition eq "HL") {
			$tagTolerance = 0.4;
			$tagToleranceUnit = 1;
			$ionSeries = "0 1 0 0 0 0 0 1 0";
		}
		## Fragment ion mass tolerance
		if ($condition eq "HL") {
			$fragMassTolerance = 0.5;
			$fragMassToleranceUnit = 1;
		} else {
			if ($searchEngine eq "JUMP") {
				$fragMassTolerance = 20;
				$fragMassToleranceUnit = 2;
			} else {
				$fragMassTolerance = 0.02;
				$fragMassToleranceUnit = 1;
			}
		}	 
		## Ion losses and dynamic modifications for phosphoproteome
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$ionLossesMS2 = "1 1 1 0 ";
			$ionLossesMS1 = 1;
			$dynamicS = 79.96633;
			$dynamicT = 79.96633;
			$dynamicY = 79.96633;
		}
		## Second search
		if ($searchEngine eq "JUMP") {
			$secondSearch = 1;
		}
		## Static modification
		if ($TMTdata == 1) {
			if ($condition eq "TMTpro" || $condition eq "TMTpro_pho") {
				$addNtermPeptide = 304.2071453;
				$addKLysine = 304.2071453;
			} else {
				$addNtermPeptide = 229.162932;
				$addKLysine = 229.162932;
			}
		}
		## Params file name
		if ($searchEngine eq "JUMP") {
			$paramsName = "jump_sj_";
		} elsif ($searchEngine eq "COMET") {
			$paramsName = "jump_sc_";
		} else {
			$paramsName = "jump_ss_";
		}
		if ($condition eq "HH") {
			$paramsName = $paramsName."HH_human.params";
		} elsif ($condition eq "HL") {
			$paramsName = $paramsName."HL_human.params";
		} elsif ($condition eq "TMThh") {
			$paramsName = $paramsName."HH_tmt10_human.params";
		} elsif ($condition eq "TMThhpho") {
			$paramsName = $paramsName."HH_pho_tmt10_human.params";
		} elsif ($condition eq "TMTpro") {
			$paramsName = $paramsName."HH_tmt16_human.params";
		} elsif ($condition eq "TMTpro_pho") {
			$paramsName = $paramsName."HH_pho_tmt16_human.params";
		}
		
		##########################
		## Print .params files	##
		##########################
		if ($condition eq "HH") {
			$paramsDir = $currDir."/HH";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "HL") {
			$paramsDir = $currDir."/HL";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMThh") {
			$paramsDir = $currDir."/TMThh";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMThhpho") {
			$paramsDir = $currDir."/TMThhpho";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMTpro") {
			$paramsDir = $currDir."/TMTpro";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMTpro_pho") {
			$paramsDir = $currDir."/TMTpro_pho";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		}
		open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
		print PARAMS "# JUMP search parameter file (Version: $version, Date: $releaseDate)\n";
		print PARAMS "\n";
		print PARAMS "search_engine = $searchEngine										# use JUMP, or COMET, or SEQUEST for database search\n";
		print PARAMS "\n";
		print PARAMS "# Database settings\n";
		# if ($condition eq "TMThh" || $condition eq "TMThhpho" || $condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			print PARAMS "database_name = $databaseName			# use .fasta.mdx for JUMP/COMET and .fasta.hdr for SEQUEST\n";
			print PARAMS "pit_file = $pitFile				# protein inference table (pit) for grouping proteins/genes\n";
		# } else {
			# print PARAMS "database_name = $databaseName				# use .fasta.mdx for JUMP/COMET and .fasta.hdr for SEQUEST\n";
			# print PARAMS "pit_file = $pitFile						# protein inference table (pit) for grouping proteins/genes\n";
		# }
		print PARAMS "peptide_tolerance = 15										# precursor mass (MH+) tolerance, default = 15 ppm after mass correction\n";
		print PARAMS "peptide_tolerance_units = 2									# 1 = Da; 2 = ppm\n";
		print PARAMS "\n";
		print PARAMS "# Preprocessing parameters\n";
		print PARAMS "first_scan_extraction = 0									# the first scan number for search\n";
		print PARAMS "last_scan_extraction = 1000000									# the last scan number for search, use a large number (e.g. 10E6) for full scans\n";
		print PARAMS "isolation_window = $isolationWindow										# +/- (isolation_window)/2 based on MS2 isolation window (e.g. 1.6 m/z)\n";
		print PARAMS "isolation_window_offset = $isolationOffset									# +/- isolation_window_offset based on MS2 isolation window offset (e.g. 0.25 m/z)\n";
		print PARAMS "isolation_window_variation = $isolationVariation								# +/- isolation_window_variation based on MS2 isolation window offset (e.g. 0.25 m/z)\n";
		print PARAMS "\n";
		print PARAMS "interscanppm = 15										# mass tolerance for interscan precursor identification\n";
		print PARAMS "intrascanppm = 10										# mass tolerance for intrascan isotopic decharging\n";
		print PARAMS "max_num_ppi = 0											# 0 = disable; 1-0 = max precursor ions selected for mixed MS2 search\n";
		print PARAMS "percentage_ppi = $percentagePPI										# minimal percentage of precursor peak intensity (ppi) when max_num_ppi = 0\n";
		print PARAMS "ppi_charge_0 = 1										# 0 = discard uncharged MS1 (charge = 0); 1 = manual charge assignment (+2 and +3)\n";
		print PARAMS "ppi_charge_1 = 1										# 0 = discard MS1 with charge +1; 1 = enable original charge +1\n";
		print PARAMS "mass_correction = $massCorrection										# 0 = no correction, 1 = MS1-based, 2 = MS1/2-based, 3 = manual correction\n";
		print PARAMS "prec_window = 3											# 0 = disable; 1-10 (Da) = mz windows for removing precursor ions\n";
		print PARAMS "MS2_deisotope = $ms2Deisotope										# 0 = disable; 1 = enable\n";
		print PARAMS "ppm = 10											# mass tolerance for MS2 decharging and deisotoping\n";
		print PARAMS "charge12_ppm = 15										# mass tolerance for merging different charged ions with the same mass\n";
		print PARAMS "ms2_consolidation = $ms2Consolidation										# maximal number of peaks retained within each 100-Da window\n";
		print PARAMS "TMT_data = $TMTdata											# 0 = disable; 1 = enable\n";
		print PARAMS "\n";
		print PARAMS "# Tagging\n";
		print PARAMS "tag_generation = $tagGeneration										# 0 = disable; 1 = enable to generate tags\n";
		print PARAMS "tag_tolerance = $tagTolerance										# mass tolerance for measuring peak distance for generating tags\n";
		print PARAMS "tag_tolerance_unit = $tagToleranceUnit										# 1 = Da; 2 = ppm\n";
		print PARAMS "tag_select_method = comb_p									# tag ranking: comb_p, hyper_p or rank_p\n";
		print PARAMS "\n";
		print PARAMS "# Database searching\n";
		print PARAMS "ion_series = $ionSeries									# a, b, c, d, v, w, x, y and z ions, respectively\n";
		print PARAMS "frag_mass_tolerance = $fragMassTolerance									# mass tolerance for MS2 ion matching\n";
		print PARAMS "frag_mass_tolerance_unit = $fragMassToleranceUnit									# 1 = Da; 2 = ppm\n";
		print PARAMS "ion_losses_MS2 = $ionLossesMS2									# 0 = disable; 1 = enable neutral loss of H2O, HPO3, H3PO4 and NH3, respectively\n";
		print PARAMS "ion_losses_MS1 = $ionLossesMS1										# 0 = disable; 1 = use precursor ion phosphate neutral loss to estimate #S/T phosphorylation\n";
		print PARAMS "ion_scoring = 1											# 1 = scoring product ions simultaneously; 2 = scoring ion series and charge states separately\n";
		print PARAMS "\n";
		print PARAMS "matching_method = hyper_p									# PSM scoring: comb_p, hyper_p, rank_p\n";
		print PARAMS "tag_search_method = 2										# 1 = exit when found; 2 = exhaustive search using tags defined by max_number_tag_for_search\n";
		print PARAMS "max_number_tags_for_search = 50									# max tags used for search unless the total number of tags is smaller than this defined value\n";
		print PARAMS "number_of_selected_result = 5									# maximal tentative PSMs in .spout ranked by Jscore\n";
		print PARAMS "number_of_detailed_result = 5									# maximal tentative PSMs in .spout ranked by pattern matching score\n";
		print PARAMS "second_search = $secondSearch										# 0 = disable; 1 = enable; for PSMs with FDR>0, perform the another round of search\n";
		print PARAMS "												# by relaxing monoisotopic mass by including M-2, M-1, M, M+1, M+2\n";
		print PARAMS "# Dynamic Modifications: SEQUEST requires no new database; but JUMP requires new database\n";
		print PARAMS "# C:  57.02146 carbamidomethylation or 71.0371 acrylamide\n";
		print PARAMS "# STY: 79.96633;  M: 15.99492; GG: 114.04293\n";
		print PARAMS "# SILAC: K:4.02511, 6.02013, 8.01420; SILAC: R:6.02013, 10.00827\n";
		print PARAMS "# TMT6-10: 229.1629321; TMT2: 225.1558327; TMT0: 224.1524779\n";
		print PARAMS "dynamic_M = 15.99492										# add each dynamic modification by one line, starting with dynamic_aa\n";
		print PARAMS "# dynamic_C = 57.02146										# add additional dynamic modification by line, starting with dynamic_aa\n";
		if (defined $dynamicS) {
			print PARAMS "dynamic_S = $dynamicS\n";
			print PARAMS "dynamic_T = $dynamicT\n";
			print PARAMS "dynamic_Y = $dynamicY\n";
		}
		print PARAMS "\n";
		print PARAMS "# Parameters for creating database (should match with the selected database)\n";
		print PARAMS "enzyme_info = Tryptic KR P									# LysC K ; ArgC R ; GluC DE ;\n";
		print PARAMS "digestion = full										# full or partial\n";
		print PARAMS "max_mis_cleavage = 2										# maximal miscleavage sites allowed for each peptide\n";
		print PARAMS "min_peptide_mass = 400.0000									# minimal mass of peptide database\n";
		print PARAMS "max_peptide_mass = 6000.0000									# maximal mass of peptide database\n";
		print PARAMS "max_modif_num = 3										# maximal modifications allowed for each peptide\n";
		print PARAMS "\n";
		print PARAMS "# Static Modification\n";
		print PARAMS "add_Nterm_peptide = $addNtermPeptide										# TMT modification or other amine labeling\n";
		print PARAMS "add_Cterm_peptide = 0.0000\n";
		print PARAMS "add_A_Alanine = 0.0000\n";
		print PARAMS "add_B_avg_NandD = 0.0000\n";
		print PARAMS "add_C_Cysteine = 57.02146										# Cys alkylation\n";
		print PARAMS "add_D_Aspartic_Acid = 0.0000\n";
		print PARAMS "add_E_Glutamic_Acid = 0.0000\n";
		print PARAMS "add_F_Phenylalanine = 0.0000\n";
		print PARAMS "add_G_Glycine = 0.0000\n";
		print PARAMS "add_H_Histidine = 0.0000\n";
		print PARAMS "add_I_Isoleucine = 0.0000\n";
		print PARAMS "add_J_user_amino_acid = 0.0000\n";
		print PARAMS "add_K_Lysine = $addKLysine										# TMT modification or other amine labeling\n";
		print PARAMS "add_L_Leucine = 0.0000\n";
		print PARAMS "add_M_Methionine = 0.0000\n";
		print PARAMS "add_N_Asparagine = 0.0000\n";
		print PARAMS "add_O_Ornithine = 0.0000\n";
		print PARAMS "add_P_Proline = 0.0000\n";
		print PARAMS "add_Q_Glutamine = 0.0000\n";
		print PARAMS "add_R_Arginine = 0.0000\n";
		print PARAMS "add_S_Serine = 0.0000\n";
		print PARAMS "add_T_Threonine = 0.0000\n";
		print PARAMS "add_U_user_amino_acid = 0.0000\n";
		print PARAMS "add_V_Valine = 0.0000\n";
		print PARAMS "add_W_Tryptophan = 0.0000\n";
		print PARAMS "add_X_LorI = 0.0000\n";
		print PARAMS "add_Y_Tyrosine = 0.0000\n";
		print PARAMS "add_Z_avg_QandE = 0.0000\n";
		print PARAMS "\n";
		print PARAMS "# Other parameters\n";
		print PARAMS "simulation = 0											# 0 = disable; 1 = enable; this function used for testing the target-decoy strategy\n";
		print PARAMS "sim_MS1 = 10											# Da addition for MS1 decoys\n";
		print PARAMS "sim_MS2 = 5											# Da window for randomized MS2 peaks\n";
		print PARAMS "cluster = 1											# 0 = disable; 1 = enable; using master node only or entire cluster\n";
		if ($searchEngine eq "JUMP" || $searchEngine eq "COMET") {
			print PARAMS "Job_Management_System = LSF									# SGE used by current cluster; other systems (e.g. LSF & PBS) may be used\n";
		} else {
			print PARAMS "Job_Management_System = SGE									# SGE used by current cluster; other systems (e.g. LSF & PBS) may be used\n";
		}
		print PARAMS "temp_file_removal = 1										# 0 = disable (keep temporary files); 1 = enable (remove temporary files)\n";
		close (PARAMS);
	}
}

##############################################
## Filtering parameter generation (jump -f)	##
##############################################
foreach my $searchEngine (@searchEngines) {
	foreach my $condition (@conditions) {
	
		next if (lc($searchEngine) eq "sequest" && ($condition eq "TMTpro" || $condition eq "TMTpro_pho"));
		
		##############################################################
		## Search engine- and condition-dependent parameter setting	##
		##############################################################
		my $input;
		my $uniqueProteinPeptide = "protein";
		my $initialOutfileFDR = 5;
		my $FDR = 2;
		my $oneHitRemoval = 0;
		my $minXCorr;
		my $mods = 0;
		my $minOutfileNumXcorrFilter = 500;
		my ($oneHitMinXCorrZ1, $oneHitMinXCorrZ2, $oneHitMinXCorrZ3);
		my $oneHitMinDcn = 0.1;
		my $paramsDir;
		my $paramsName;
		## Input name
		my $apps_path;
		if ($searchEngine eq "JUMP"|| $searchEngine eq "COMET") {
			$apps_path = "/hpcf/authorized_apps/proteomics_apps";
		} else {
			$apps_path = "/data1";
		}
		if ($condition eq "HH") {
			$input = "HH_human_".lc($searchEngine).":".$apps_path."/pipeline/release/version$version"."/SampleData/HH/HH_human_".lc($searchEngine)."/HH_human_".lc($searchEngine).".1";				
		} elsif ($condition eq "HL") {
			$input = "HL_human_".lc($searchEngine).":".$apps_path."/pipeline/release/version$version"."/SampleData/HL/HL_human_".lc($searchEngine)."/HL_human_".lc($searchEngine).".1";
		} elsif ($condition eq "TMThh") {
			$input = "HH_tmt10_human_".lc($searchEngine).":".$apps_path."/pipeline/release/version$version"."/SampleData/TMThh/HH_tmt10_human_".lc($searchEngine)."/HH_tmt10_human_".lc($searchEngine).".1";
		} elsif ($condition eq "TMThhpho") {
			$input = "HH_pho_tmt10_human_".lc($searchEngine).":".$apps_path."/pipeline/release/version$version"."/SampleData/TMThhpho/HH_pho_tmt10_human_".lc($searchEngine)."/HH_pho_tmt10_human_".lc($searchEngine).".1";
		} elsif ($condition eq "TMTpro") {
			$input = "HH_tmt16_human_".lc($searchEngine).":".$apps_path."/pipeline/release/version$version"."/SampleData/TMTpro/HH_tmt16_human_".lc($searchEngine)."/HH_tmt16_human_".lc($searchEngine).".1";
		} elsif ($condition eq "TMTpro_pho") {
			$input = "HH_pho_tmt16_human_".lc($searchEngine).":".$apps_path."/pipeline/release/version$version"."/SampleData/TMTpro_pho/HH_pho_tmt16_human_".lc($searchEngine)."/HH_pho_tmt16_human_".lc($searchEngine).".1";	
		}
		## Protein or peptide
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$uniqueProteinPeptide = "peptide";
		}
		## Initial outfile FDR
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$initialOutfileFDR = 10;
		}
		## FDR
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$FDR = 2;
		}
		## One hit wonders removal
		if ($condition eq "TMThh" || $condition eq "TMTpro") {
			$oneHitRemoval = 2;
		}
		## minXcorr
		if ($searchEngine eq "JUMP") {
			$minXCorr = 10;
		} else {
			$minXCorr = 1;
		}
		## Modifications
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$mods = "STY";
		}
		## pit_file
		my $pitFile = "0";
		if ($searchEngine eq "COMET") {
			if ($condition eq "HH" || $condition eq "HL") {
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57.pit";
			} elsif ($condition eq "TMThh") {
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_TMT_K229.pit";
			} elsif ($condition eq "TMThhpho") {
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_pho_TMT_K229.pit";
			} elsif ($condition eq "TMTpro") {
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_TMTpro.pit";
			} elsif ($condition eq "TMTpro_pho") {
				$pitFile = $apps_path."/database/20200422/HUMAN/human_ft_mc2_c57_pho_TMTpro.pit";
			}
		}
		## Minimum outfile number for Xcorr filtering
		if ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$minOutfileNumXcorrFilter = 200;
		}
		## One-hit wonders
		if ($searchEngine eq "JUMP") {
			if ($condition eq "TMThh" || $condition eq "TMTpro") {
				$oneHitMinXCorrZ1 = 100;
				$oneHitMinXCorrZ2 = 40;
				$oneHitMinXCorrZ3 = 40;
			} else {
				$oneHitMinXCorrZ1 = 100;
				$oneHitMinXCorrZ2 = 25;
				$oneHitMinXCorrZ3 = 35;
			}
		} else {
			$oneHitMinXCorrZ1 = 10;
			$oneHitMinXCorrZ2 = 2.5;
			$oneHitMinXCorrZ3 = 3.5;
		}
		if ($condition eq "TMThh" || $condition eq "TMTpro") {
			$oneHitMinDcn = 0;
		}
		## Params file name
		if ($searchEngine eq "JUMP") {
			$paramsName = "jump_fj_";
		} elsif ($searchEngine eq "COMET") {
			$paramsName = "jump_fc_";
		} else {
			$paramsName = "jump_fs_";
		}
		if ($condition eq "HH") {
			$paramsName = $paramsName."HH_human.params";
		} elsif ($condition eq "HL") {
			$paramsName = $paramsName."HL_human.params";
		} elsif ($condition eq "TMThh") {
			$paramsName = $paramsName."HH_tmt10_human.params";
		} elsif ($condition eq "TMThhpho") {
			$paramsName = $paramsName."HH_pho_tmt10_human.params";
		} elsif ($condition eq "TMTpro") {
			$paramsName = $paramsName."HH_tmt16_human.params";
		} elsif ($condition eq "TMTpro_pho") {
			$paramsName = $paramsName."HH_pho_tmt16_human.params";
		}
		
		##########################
		## Print .params files	##
		##########################
		if ($condition eq "HH") {
			$paramsDir = $currDir."/HH";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "HL") {
			$paramsDir = $currDir."/HL";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMThh") {
			$paramsDir = $currDir."/TMThh";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMThhpho") {
			$paramsDir = $currDir."/TMThhpho";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMTpro") {
			$paramsDir = $currDir."/TMTpro";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		} elsif ($condition eq "TMTpro_pho") {
			$paramsDir = $currDir."/TMTpro_pho";
			if (!-e $paramsDir) {
				system("mkdir $paramsDir");
			}
			$paramsName = $paramsDir."/".$paramsName;
		}
		open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
		print PARAMS "# JUMP filtering parameter file (Version: $version, Date: $releaseDate)\n";
		print PARAMS "\n";
		print PARAMS "# Grouping # Input of the program, using full path of the search result folders (containing dta files and out/spout files)\n";
		print PARAMS "# Information (e.g., search engine, pit table) will be directly parsed from jump.params in the input path below\n";
		print PARAMS "\n";
		print PARAMS "$input\n";
		print PARAMS "\n";
		print PARAMS "##### commonly adjusted parameters ############################################################################################################\n";
		if ($searchEngine eq "COMET") {
			print PARAMS "\n";
			print PARAMS "search_engine = ".lc($searchEngine)."\n";
			print PARAMS "\n";
		}
		print PARAMS "# PSMs filtered by (i) defined minimum filtering parameters, (ii) mass accuracy, and (iii) scoring\n";
		print PARAMS "# For scoring filtering, PSMs filtered by (i) initial FDR, (ii) peptide or protein categorization and mupltistep FDR filtering, and (iii) manual one hit-wonder-removal\n";
		print PARAMS "unique_protein_or_peptide = $uniqueProteinPeptide		# use protein or peptide FDR as cutoff\n";
		print PARAMS "initial_outfile_fdr = $initialOutfileFDR				# %initial FDR for score filtering; default = 5 (%)\n";
		print PARAMS "multistep_FDR_filtering = 1			# 0 = disabled; 1 = enabled\n";
		print PARAMS "FDR = $FDR						# %FDR for filtering peptides or one-hit-wonder proteins (fixed <1% FDR for proteins matched by two or more precursors)\n";
		print PARAMS "one_hit_wonders_removal = $oneHitRemoval			# keep or remove one hit wonders (-1: removal all, 0:no filter, 1: partial+fully, 2: fully)\n";	
		print PARAMS "min_protein_SC = 1				# minimum spectral counts requirement for proteins\n";
		print PARAMS "mods = $mods					# Display modified peptides and their unmodified (0:Off, K:Lys, STY: Phosphorylation, ...)\n";
		print PARAMS "modpairs = 0					# Show modified peptides pairs or just modified peptides (0:only modified peptides, 1:modified pairs)\n";
		print PARAMS "pit_file = $pitFile					# absolute path of pit file: use updated pit file; 0 = using pit file in jump.params in the search folder\n";
		print PARAMS "DB_composite = 0				# 0 = turn off filtering; 1 = only includes core proteins (n = ~20k); 2 = the whole uniProt database (n = ~80k). This option is used only when a multi-tier database was used for database search\n";
		print PARAMS "\n";
		print PARAMS "# Minimum filtering parameters for removing low quality PSMs during reading process\n";
		print PARAMS "min_peptide_length = 7				# peptide length (6 can be used for small database)\n";
		print PARAMS "max_peptide_mis = 2				# maximal number of miscleavages allowed for one peptide, default=2\n";
		print PARAMS "max_peptide_mod = 3				# maximal number of modifications allowed for one peptide, M = 2, SILAC (KR) = 4, Ub = 3, Pho (STY) = 5\n";
		print PARAMS "peptide_mod_removal = 0				# 0: Off, C: Remove all C-modified peptides, STY: Remove all STY-modifed peptides\n";
		print PARAMS "peptide_aa_removal = 0				# 0: Off, M: Remove all M-containing peptides\n";
		print PARAMS "min_XCorr = $minXCorr					# XCorr (default = 1) or Jscore (default = 10)\n";
		print PARAMS "min_dCn = 0					# dCn or dJ\n";
		print PARAMS "mix_label = 0					# Remove mixed labeled peptides:  (0: None, KR: SILAC, C: ICAT, etc...)\n";
		print PARAMS "filter_contaminants = 0				# 0: Not used, 1: remove listed contaminants named with \"CON_\"\n";
		print PARAMS "prioritize_contaminants = 1			# used to assign representitive unique protein for shared peptides. 0: prefer core proteins; 1: prefer contaminants\n";
		print PARAMS "12combinations = 1 1 1 1 1 1 1 1 0 0 0 0	# Trypticity and charge => FT1 FT2 FT3 FT4 PT1 PT2 PT3 PT4 NT1 NT2 NT3 NT4 # 1=yes, 0=no\n";
		print PARAMS "\n";
		print PARAMS "# Filtering PSMs by mass accuracy (no grouping, mass correction for each LC run) and matching scores (grouped)\n";
		print PARAMS "bypass_filtering = 0				# 0: NO, 1: YES bypasses all mass accuracy and dCn/XCorr filtering\n";
		if ($searchEngine eq "COMET") {
			print PARAMS "mass_accuracy = 0				# Mass accuracy filtering # 1=yes, 0=no\n";
		} else {
			print PARAMS "mass_accuracy = 1				# Mass accuracy filtering # 1=yes, 0=no\n";
		}
		print PARAMS "mass_consideration = 1				# Mass consideration for accuracy filtering => 1:(MH), 2:(MH,MH+1), 3:(MH,MH+1,MH+2), 4:(MH,MH+1,MH+2,MH+3),\n";
		print PARAMS "						# 5:(MH,MH+1,MH+2,MH+3,MH+4), 6:(MH-1,MH,MH+1,MH+2), 7:(MH-2,MH-1,MH,MH+1,MH+2)\n";
		print PARAMS "sd_or_static = sd				# Mass accuracy cutoff based on experimental standard deviation (sd_or_static = sd)\n";
		print PARAMS "sd = 5						# or static ppm values (sd_or_static = static)\n";
		print PARAMS "static_cutoff = 6				# ppm\n";
		print PARAMS "static_cutoff_without_mass_calib = 10		# ppm; if not enough good scans, use this threshold for ppm cut without mass calibration\n";
		print PARAMS "\n";
		print PARAMS "# Filtering PSMs by matching scores (grouping by Peptide length; Trypticity; Mod; Miscleavage; Charge; deltaCn (0.01 step)\n";
		print PARAMS "# Sorting outfile into different dynamic groups until each group has sufficient outfiles (e.g. min_outfile_num_for_XCorr_filter = 500)\n";
		print PARAMS "# Filtering by assigned scan FDR based on unique peptides or proteins.\n";
		print PARAMS "# Removing false outfiles (if no charge state found, assign both +2 and +3 to make two dta files, same SC, same m/z, different charge state)\n";
		print PARAMS "# Grouping SC (1000) into unique SC (350), peptides (500), unique peptides (300), proteins (900), unique proteins (150), and protein groups (120)\n";
		print PARAMS "# Using SC FDR to predict unique protein/peptide FDR to shorten the filtering process\n";
		print PARAMS "FDR_filtering_method = group			# LDA or group (select one of the two filtering methods)\n";
		print PARAMS "min_outfile_num_for_XCorr_filter = $minOutfileNumXcorrFilter		# number of outfiles in each group for XCorr filtering; any number between 500 and 1000 is recomemded\n";
		print PARAMS "\n";
		print PARAMS "# Applyling additional filtering for one-hit-wonders\n";
		print PARAMS "one_hit_wonders_min_XCorr_z1 = $oneHitMinXCorrZ1		# minimum XCorr for peptides with charge state 1\n";
		print PARAMS "one_hit_wonders_min_XCorr_z2 = $oneHitMinXCorrZ2		# minimum XCorr for peptides with charge state 2\n";
		print PARAMS "one_hit_wonders_min_XCorr_z3 = $oneHitMinXCorrZ3		# minimum XCorr for peptides with charge state 3 or above\n";
		print PARAMS "one_hit_wonders_min_dCn = $oneHitMinDcn			# minimum dCn\n";
		print PARAMS "one_hit_wonders_mis = 1				# number of miscleavages allowed for one hit wonders\n";
		print PARAMS "one_hit_wonders_mods = 1			# number of modifications allowed for hit wonders, M = 1, SILAC (KR) = 3, Ub = 2, Pho (STY) = 4\n";
		print PARAMS "######################################################################################################################################################\n";
		print PARAMS "\n";
		print PARAMS "#################### To turn on pepXML generation ######################\n";
		print PARAMS "output_pepXML = 0\n";
		close (PARAMS);
	}
}

##########################################################
## Quantification parameter file generation (jump -q)	##
##########################################################
foreach my $searchEngine (@searchEngines) {	
	foreach my $condition (@conditions) {
		next if ($condition eq "HH" || $condition eq "HL");
		##############################################################
		## Search engine- and condition-dependent parameter setting	##
		##############################################################
		my $paramsDir;
		my $paramsName;
		my $idTxt;
		my $saveDir;
		my $min_intensity_method_1_2_psm;
		my $min_intensity_value_1_2_psm;
		my $percentage_trimmed;
		my $apps_path;
		if ($searchEngine eq "JUMP"|| $searchEngine eq "COMET") {
			$apps_path = "/hpcf/authorized_apps/proteomics_apps";
		} else {
			$apps_path = "/data1";
		}
		if ($searchEngine eq "JUMP"|| $searchEngine eq "COMET") {
			if ($condition eq "TMThh") {
				$paramsDir = $currDir."/TMThh";
				if (!-e $paramsDir) {
					system("mkdir $paramsDir");
				}
				if ($searchEngine eq "JUMP") {
					$paramsName = $paramsDir."/jump_qj_HH_tmt10_human.params";
				} else {
					$paramsName = $paramsDir."/jump_qc_HH_tmt10_human.params";
				}
				$idTxt = $apps_path."/pipeline/release/version$version/SampleData/TMThh/sum_HH_tmt10_human_".lc($searchEngine)."/ID.txt";
				$saveDir = "HH_tmt10_human_".lc($searchEngine);
			} elsif ($condition eq "TMThhpho") {
				$paramsDir = $currDir."/TMThhpho";
				if (!-e $paramsDir) {
					system("mkdir $paramsDir");
				}
				if ($searchEngine eq "JUMP") {
					$paramsName = $paramsDir."/jump_qj_HH_pho_tmt10_human.params";
				} else {
					$paramsName = $paramsDir."/jump_qc_HH_pho_tmt10_human.params";
				}
				$idTxt = $apps_path."/pipeline/release/version$version/SampleData/TMThhpho/sum_HH_pho_tmt10_human_".lc($searchEngine)."_mod/IDmod.txt";
				$saveDir = "HH_pho_tmt10_human_".lc($searchEngine)."_mod";
			} elsif ($condition eq "TMTpro") {
				$paramsDir = $currDir."/TMTpro";
				if (!-e $paramsDir) {
					system("mkdir $paramsDir");
				}
				if ($searchEngine eq "JUMP") {
					$paramsName = $paramsDir."/jump_qj_HH_tmt16_human.params";
				} else {
					$paramsName = $paramsDir."/jump_qc_HH_tmt16_human.params";
				}
				$idTxt = $apps_path."/pipeline/release/version$version/SampleData/TMTpro/sum_HH_tmt16_human_".lc($searchEngine)."/ID.txt";
				$saveDir = "HH_tmt16_human_".lc($searchEngine);
			} elsif ($condition eq "TMTpro_pho") {
				$paramsDir = $currDir."/TMTpro_pho";
				if (!-e $paramsDir) {
					system("mkdir $paramsDir");
				}
				if ($searchEngine eq "JUMP") {
					$paramsName = $paramsDir."/jump_qj_HH_pho_tmt16_human.params";
				} else {
					$paramsName = $paramsDir."/jump_qc_HH_pho_tmt16_human.params";
				}
				$idTxt = $apps_path."/pipeline/release/version$version/SampleData/TMTpro_pho/sum_HH_pho_tmt16_human_".lc($searchEngine)."_mod/IDmod.txt";
				$saveDir = "HH_tmt16_human_".lc($searchEngine)."_mod";
			}
		} else {
			if ($condition eq "TMThh") {
					$paramsDir = $currDir."/TMThh";
				if (!-e $paramsDir) {
					system("mkdir $paramsDir");
				}
				$paramsName = $paramsDir."/jump_qs_HH_tmt10_human.params";
				$idTxt = $apps_path."/pipeline/release/version$version/SampleData/TMThh/sum_HH_tmt10_human_".lc($searchEngine)."/ID.txt";
				$saveDir = "HH_tmt10_human_".lc($searchEngine);
			} elsif ($condition eq "TMThhpho") {
				$paramsDir = $currDir."/TMThhpho";
				if (!-e $paramsDir) {
					system("mkdir $paramsDir");
				}
				$paramsName = $paramsDir."/jump_qs_HH_pho_tmt10_human.params";
				$idTxt = $apps_path."/pipeline/release/version$version/SampleData/TMThhpho/sum_HH_pho_tmt10_human_".lc($searchEngine)."_mod/IDmod.txt";
				$saveDir = "HH_pho_tmt10_human_".lc($searchEngine)."_mod";
			} elsif ($condition eq "TMTpro" || $condition eq "TMTpro_pho") {
				next;
			}
		}
		my $impurityMatrix = $apps_path."/pipeline/release/version$version/JUMPq/TMT10.ini";
		if ($condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			$impurityMatrix = $apps_path."/pipeline/release/version$version/JUMPq/TMT16.ini";
		}
		
		##########################
		## Print .params files	##
		##########################
		open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
		print PARAMS "# JUMP quantification parameter file (Version: $version, Date: $releaseDate)\n";
		print PARAMS "# Input:  ID.txt or IDmod.txt\n";
		print PARAMS "idtxt = $idTxt\n";
		print PARAMS "id_all_prot_quan = 0\n";
		print PARAMS "# 0 = skip the generation of a pubilcation table combining whole proteome and phosphopeptides\n";
		print PARAMS "# otherwise, put the full path of 'id_all_prot_quan.xlsx' file after whole proteome quantification analysis\n";
		print PARAMS "save_dir = $saveDir						# name of the directory for JUMPq results (prefix \"quan-\" will be added)\n";	
		print PARAMS "ppi_filter = 50								# precursor peak intensity percentage threshold\n";
		print PARAMS "\n";
		print PARAMS "# Minimum intensity-based filtering of PSM(s)\n";
		print PARAMS "# Multiple filters can be used\n";
		print PARAMS "# e.g. min_intensity_method = 1, 4      -> minimum intensity and median intensity of PSM are evaluated\n";
		print PARAMS "#      min_intensity_value = 1000, 5000 -> intensity threshold for each filtering method\n";
		print PARAMS "min_intensity_method = 1, 4						# 0 = no use of the filter, 1 = minimum, 2 = maximum, 3 = mean, 4 = median\n";
		print PARAMS "min_intensity_value = 1000, 5000					# Minimum intensity threshold\n";
		print PARAMS "# Minimum intensity-based filtering of PSM(s) used for summarizing a protein\n";
		print PARAMS "# Multiple filters can be used as above\n";
		if ($condition eq "TMThh" || $condition eq "TMTpro") {
			$min_intensity_method_1_2_psm = "1, 4";
			$min_intensity_value_1_2_psm = "2000, 10000";
		} elsif ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$min_intensity_method_1_2_psm = "0";
			$min_intensity_value_1_2_psm = "0";			
		}
		print PARAMS "min_intensity_method_1_2_psm = $min_intensity_method_1_2_psm					# 0 = no use of the filter, 1 = minimum, 2 = maximum, 3 = mean, 4 = median\n";
		print PARAMS "min_intensity_value_1_2_psm = $min_intensity_value_1_2_psm				# Minimum intensity threshold\n";
		print PARAMS "\n";
		print PARAMS "# Impurity correction parameters\n";
		print PARAMS "impurity_correction = 1							# 1 = Yes; 0 = No; if only a part of reporters are used, it should be set to 0\n";
		print PARAMS "impurity_matrix = $impurityMatrix	# impurity table for correction\n";
		print PARAMS "\n";
		print PARAMS "# Loading-bias correction is generally required to remove systematic biases of mass spectrometry data\n";
		print PARAMS "loading_bias_correction = 1						# 1 = Yes; 0 = No;\n";
		print PARAMS "loading_bias_correction_method = 1					# 1 = mean; 2 = median;\n";
		print PARAMS "SNratio_for_correction = 10						# define the minimal signal (SN ratio) for the correction\n";
		if ($condition eq "TMThh" || $condition eq "TMTpro") {
			$percentage_trimmed = 25;
		} elsif ($condition eq "TMThhpho" || $condition eq "TMTpro_pho") {
			$percentage_trimmed = 50;
		}
		print PARAMS "percentage_trimmed = $percentage_trimmed							# percentage of most variable intensities to be trimmed for the correction\n";
		print PARAMS "\n";
		print PARAMS "# Interference removal in TMT-quantification\n";
		print PARAMS "interference_removal = 0						# 1 = Yes; 0 = No;\n";
		print PARAMS "\n";
		print PARAMS "# Names of TMT reporters used\n";
		print PARAMS "# TMT reporter ion masses are as follows\n";
		print PARAMS "# TMT16 reporters (126.127726;127.124761;127.131081;128.128116;128.134436;129.131471;129.137790;130.134825;130.141145;131.138180;131.1445001;132.141535;132.147855;133.144889;133.151209;134.148244)\n";
		print PARAMS "# TMT11 reporters (126.127726;127.124761;127.131081;128.128116;128.134436;129.131471;129.137790;130.134825;130.141145;131.138180;131.1445001)\n";
		print PARAMS "# TMT10 reporters (126.127726;127.124761;127.131081;128.128116;128.134436;129.131471;129.137790;130.134825;130.141145;131.138180)\n";
		print PARAMS "# TMT8 reporters (126.127726;127.124761;127.131081;128.134436;129.131471;129.137790;130.141145;131.138180)\n";
		print PARAMS "# TMT6 reporters (126.127726;127.124761;128.134436;129.131471;130.141145;131.138180)\n";
		if ($condition eq "TMThh" || $condition eq "TMThhpho") {
			print PARAMS "tmt_reporters_used = sig126; sig127N; sig127C; sig128N; sig128C; sig129N; sig129C; sig130N; sig130C; sig131\n";
		} elsif ($condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			print PARAMS "tmt_reporters_used = sig126; sig127N; sig127C; sig128N; sig128C; sig129N; sig129C; sig130N; sig130C; sig131N; sig131C; sig132N; sig132C; sig133N; sig133C; sig134N\n";
		}
		print PARAMS "tmt_peak_extraction_second_sd = 8					# SD used for identification of reporter ions\n";
		print PARAMS "tmt_peak_extraction_method = 1						# 1 = strongest intensity; 2 = closest to expected report ion mass; only if multiple peaks detected within mass tolerance\n";
		print PARAMS "\n";
		print PARAMS "# Sample labels corresponding the reporters used\n";
		print PARAMS "# Do NOT use any special characters other than underscore, \"_\" \n";
		print PARAMS "sig126 = S1\n";
		print PARAMS "sig127N = S2\n";
		print PARAMS "sig127C = S3\n";
		print PARAMS "sig128N = S4\n";
		print PARAMS "sig128C = S5\n";
		print PARAMS "sig129N = S6\n";
		print PARAMS "sig129C = S7\n";
		print PARAMS "sig130N = S8\n";
		print PARAMS "sig130C = S9\n";
		if ($condition eq "TMThh" || $condition eq "TMThhpho") {
			print PARAMS "sig131 = S10\n";
		} elsif ($condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			print PARAMS "sig131N = S10\n";
			print PARAMS "sig131C = S11\n";
			print PARAMS "sig132N = S12\n";
			print PARAMS "sig132C = S13\n";
			print PARAMS "sig133N = S14\n";
			print PARAMS "sig133C = S15\n";
			print PARAMS "sig134N = S16\n";
		}
		print PARAMS "\n";
		print PARAMS "# The program allows multiple comparisons (e.g. comparison_groups_comp1, do not change the prefix \"comparison_groups_\")\n";
		print PARAMS "# e.g. sample labels are S1, S2, S3, S4, S5 : S6, S7, S8, S9 and S10 for all TMT10 reporters (sorted by mass)\n";
		print PARAMS "#      comparison_groups_twoGroups = S1, S2, S3, S4, S5 : S6, S7, S8, S9, S10\n";
		print PARAMS "#      comparison_groups_threeGroups = S1, S2, S3 : S4, S5, S6, S7 : S8, S9, S10\n";
		print PARAMS "comparison_analysis = 0							# 1 = Yes; 0 = No; for group comparison\n";
		if ($condition eq "TMThh" || $condition eq "TMThhpho") {
			print PARAMS "comparison_groups_twoGroups = S1, S2, S3, S4, S5 : S6, S7, S8, S9, S10\n";
		} elsif ($condition eq "TMTpro" || $condition eq "TMTpro_pho") {
			print PARAMS "comparison_groups_twoGroups = S1, S2, S3, S4, S5, S6, S7, S8 : S9, S10, S11, S12, S13, S14, S15, S16\n";
		}
		close (PARAMS);
	}
}

##################################################
## Database parameter file generation (jump -d)	##
##################################################
my $paramsDir = $currDir;
if (!-e $paramsDir) {
	system ("mkdir $paramsDir");
}
my $paramsName = $paramsDir."/jump_d.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP database generation parameter file (Version: $version, Date: $releaseDate)\n";
print PARAMS "# JUMPd generates a search database and/or a protein inference table (PIT) using the input databases (.fasta files)\n";
print PARAMS "# The type of a database (for JUMP or SEQUEST) solely depends on the search_engine information in \"jump.params\" file below\n";
print PARAMS "# All the modification information for the database also depends on the \"jump.params\" file\n";
print PARAMS "\n";
print PARAMS "# Parameters for generating a new database ######################################################################################################################################\n";
print PARAMS "input_database1 = /hpcf/authorized_apps/proteomics_apps/database/20150201/HUMAN.fasta						# Absolute path of input_database1 (i.e. .fasta file)\n";
print PARAMS "#input_database2 = /hpcf/authorized_apps/proteomics_apps/database/20150201/MOUSE.fasta						# Absolute path of input_database2\n";
print PARAMS "												# More databases can be used (e.g. input_database3 = /hpcf/authorized_apps/proteomics_apps/database/20150201/ECOLI.fasta)\n";
print PARAMS "output_prefix = human										# Prefix for a new database (and .pit) file\n";
print PARAMS "include_contaminants = 1									# 0 = do not include contaminants; 1 = include contaminants\n";
print PARAMS "input_contaminants = /hpcf/authorized_apps/proteomics_apps/database/contaminants.fasta						# Absolute path of a .fasta file containing contaminants\n";
print PARAMS "decoy_generation = 1										# 0 = do not include decoys; 1 = include decoys\n";
print PARAMS "decoy_generation_method = 2									# 1 = reverse; 2 = reverse and switch every K/R with its preceding AA\n";
print PARAMS "jump.params = /usr/search/jump_search.params							# Only search engine and modification information will be obtained from the file\n";
print PARAMS "												# \"database_name\" in a jump.params file will be ignored\n";
print PARAMS "bypass_db_generation = 0									# 0 = generate database, 1 = bypass the generation of database (only pit will be generated)\n";
print PARAMS "\n";
print PARAMS "# Parameters for generating a protein inference table (PIT) (keep the prefix \"list_\") ###########################################################################################\n";
print PARAMS "list_protein_abundance1 = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/ProteinAbundance/Human_Abundance_emPAI.txt	# Absolute path of a file containing protein abundance information\n";
print PARAMS "												# More abundance information can be used\n";
print PARAMS "												# (e.g. list_protein_abundance2 = /hpcf/authorized_apps/proteomics_apps/database/Rat_Abundance.txt)\n";
print PARAMS "list_TFs = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/TFs/tfs_from_TRANSFAC.txt				# Absolute path of a file containing protein annotation information, TFs (transcription factors)\n";
print PARAMS "list_oncogenes = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/Oncogenes/oncogenes_from_literatures.txt	# Absolute path of a file containing protein annotation information, oncogenes\n";
print PARAMS "list_kinases = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/Kinases/kinases_from_pkinfam.txt			# Absolute path of a file containing protein annotation information, kinases\n";
print PARAMS "list_GPCRs = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/GPCRs/gpcrs.txt					# Absolute path of a file containing protein annotation information, GPCRs\n";
print PARAMS "list_epigenetic_factors = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/EpigeneticRegulators/epigenetic_regulators.txt\n";
print PARAMS "list_spliceosomal_proteins = /hpcf/authorized_apps/proteomics_apps/database/KnowledgeTables/SpliceosomalProteins/spliceosomal_proteins.txt\n";
close (PARAMS);

##################################################################
## Absolute quantification parameter file generation (jump -aq)	##
##################################################################
$paramsName = $paramsDir."/jump_aq.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP absolute quantification parameter file (Version: $version, Date: $releaseDate)\n";
print PARAMS "# JUMPaq generates a protein abundance table based on a search/filtering result\n";
print PARAMS "\n";
print PARAMS "# Database (i.e. a fasta file)\n";
print PARAMS "database = /hpcf/authorized_apps/proteomics_apps/database/20200422/HUMAN/human_ft_mc2_c57.fasta\n";
print PARAMS "\n";
print PARAMS "# The Report file generated by JUMPf\n";
print PARAMS "report_file = /hpcf/authorized_apps/proteomics_apps/pipeline/release/version$version/SampleData/HH/sum_HH_human_jump/publications/id_all_prot.txt\n";
print PARAMS "\n";
print PARAMS "# Output file name\n";
print PARAMS "output = protein_absolute_abundance.txt\n";
print PARAMS "\n";
print PARAMS "# Parameters used for calculating theoretical peptides\n";
print PARAMS "min_peptide_length = 6\n";
print PARAMS "enzyme = trypsin			#types of enzyme: trypsin, chymotrypsin, gluc_nahpo, gluc, lysc, argc, aspc\n";
print PARAMS "max_peptide_length = 30\n";
print PARAMS "max_peptide_hydro = 17\n";
print PARAMS "min_peptide_hydro = -24\n";
close (PARAMS);

##################################################################
## Statistical inference parameter file generation (jump -i)	##
##################################################################
$paramsName = $paramsDir."/jump_i_default.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP statistical inference parameter file (Version: $version, Date: $releaseDate)\n";
print PARAMS "\n";
print PARAMS "#-----------------------------------------------------------------------------------------------------------------------------------\n";
print PARAMS "# Expected results:\n";
print PARAMS "#\n";
print PARAMS "# 1) log2-ratio distribution for each pair of samples:\n";
print PARAMS "# 	a) log2-ratio distributions figure: log2ratio_distributions.pdf\n";
print PARAMS "# 	b) log2-ratio distribution mean: log2ratio_mean_matrix.txt (typical mean for replicates is around 0)\n";
print PARAMS "# 	c) log2-ratio distribution SD: log2ratio_SD_matrix.txt (typical SD for replicates is 0.2)\n";
print PARAMS "#\n";
print PARAMS "# 2) Heatmap for sample cluster: heatmap_XXpct.pdf (default cutting %: 0.1, 0.5, 1, 5, 10 and 20)\n";
print PARAMS "#\n";
print PARAMS "#-----------------------------------------------------------------------------------------------------------------------------------\n";
print PARAMS "\n";
print PARAMS "# input file (either protein or peptide table from jump -q results in folder 'publications')\n";
print PARAMS "input_table = /hpcf/authorized_apps/proteomics_apps/pipeline/release/version$version/SampleData/TMThh/quan_HH_tmt10_human_jump/publications/id_uni_prot_quan.txt		# absolute path needed;\n"; 
print PARAMS "										# protein file: /home/user/project/quan_test1/publications/id_uni_prot_quan.txt\n";
print PARAMS "										# peptide file: /home/user/project/quan_test1/publications/id_uni_pep_quan.txt\n";
print PARAMS "\n";
print PARAMS "# sample labels\n";
print PARAMS "sig126 = condition1a\n";
print PARAMS "sig127N = condition1b\n";
print PARAMS "sig127C = condition2a\n";
print PARAMS "sig128N = condition2b\n";
print PARAMS "sig128C = condition3a\n";
print PARAMS "sig129N = condition3b\n";
print PARAMS "sig129C = condition4a\n";
print PARAMS "sig130N = condition4b\n";
print PARAMS "sig130C = condition5a\n";
print PARAMS "sig131 = condition5b\n";
print PARAMS "\n";
print PARAMS "# output folder\n";
print PARAMS "output_folder = test1				# output folder suffix name; prefix always 'inf_'\n";
print PARAMS "\n";
print PARAMS "# contaminant removel option\n";
print PARAMS "remove_contaminants = 1				# remove contaminants? 1 = yes; 0 = no\n";
print PARAMS "\n";
print PARAMS "# SD / mean matrix: analysis based on the stable proteins / peptides\n";
print PARAMS "pair_cutoff_percentage = 10			# percentage/2 of data will be ignored on each end of the distribution\n";
print PARAMS "pair_cutoff_intensity = 3000			# median intensity cutoff across samples\n";
print PARAMS "\n";
print PARAMS "# heatmap / sample clustering: analysis based on the most variable proteins / peptides\n";
print PARAMS "bypass_row_clustering = 0			# deactivate row (i.e., protein / peptide) clustering in the heatmap\n";
print PARAMS "cluster_cutoff_percentage = 0.5			# percentage of most variable proteins (defined by RSD of intensity) used for clustering\n";
print PARAMS "cluster_cutoff_intensity = 3000			# median intensity cutoff across samples\n";
close (PARAMS);

$paramsName = $paramsDir."/jump_i_custom.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP statistical inference parameter file (Version: $version, Date: $releaseDate)\n";
print PARAMS "\n";
print PARAMS "#-----------------------------------------------------------------------------------------------------------------------------------\n";
print PARAMS "# Expected results:\n";
print PARAMS "#\n";
print PARAMS "# 1) log 2 ratio distribution for each pair of samples:\n";
print PARAMS "# 	a) log 2 ratio distributions figure: log2ratio_distributions.pdf\n";
print PARAMS "# 	b) log 2 ratio distribution mean: log2ratio_mean_matrix.txt (typical mean for replicates is around 0)\n";
print PARAMS "# 	c) log 2 ratio distribution SD: log2ratio_SD_matrix.txt (typical SD for replicates is 0.2)\n";
print PARAMS "#\n";
print PARAMS "# 2) Heatmap for sample cluster: heatmap_XXpct.pdf (default cutting %: 0.1, 0.5, 1, 5, 10 and 20)\n";
print PARAMS "#\n";
print PARAMS "#-----------------------------------------------------------------------------------------------------------------------------------\n";
print PARAMS "\n";
print PARAMS "# customized input\n";
print PARAMS "# 1) Excel: make an Excel sheet with format below:\n";
print PARAMS "# customID sig126 sig127N ... sig131\n";
print PARAMS "# 2) Excel: save the file as 'Text (Tab delimited)'\n";
print PARAMS "# 3) WinSCP: upload the saved file to cluster using WinSCP\n";
print PARAMS "# 4) JUMPi: turn off all filtering in jump -i parameter file (default)\n";
print PARAMS "input_table = /home/yli4/development/JUMPi/v11.3.042915/cus_prot1.txt				# absolute path of customized input file\n";
print PARAMS "\n";
print PARAMS "# sample labels\n";
print PARAMS "sig126 = condition1a\n";
print PARAMS "sig127N = condition1b\n";
print PARAMS "sig127C = condition2a\n";
print PARAMS "sig128N = condition2b\n";
print PARAMS "sig128C = condition3a\n";
print PARAMS "sig129N = condition3b\n";
print PARAMS "sig129C = condition4a\n";
print PARAMS "sig130N = condition4b\n";
print PARAMS "sig130C = condition5a\n";
print PARAMS "sig131 = condition5b\n";
print PARAMS "\n";
print PARAMS "# output folder\n";
print PARAMS "output_folder = cu_test1				# output folder suffix name; prefix always 'inf_'\n";
print PARAMS "\n";
print PARAMS "# contaminant removel option\n";
print PARAMS "remove_contaminants = 0				# remove contaminants? 1 = yes; 0 = no\n";
print PARAMS "\n";
print PARAMS "# SD / mean matrix: analysis based on the stable proteins / peptides\n";
print PARAMS "pair_cutoff_percentage = 0			# percentage/2 of data will be ignored on each end of the distribution\n";
print PARAMS "pair_cutoff_intensity = 0			# median intensity cutoff across samples\n";
print PARAMS "\n";
print PARAMS "# heatmap / sample clustering: analysis based on the most variable proteins / peptides\n";
print PARAMS "bypass_row_clustering = 0			# deactivate row (i.e., protein / peptide) clustering in the heatmap\n";
print PARAMS "cluster_cutoff_percentage = 100			# percentage of most variable proteins (defined by RSD of intensity) used for clustering\n";
print PARAMS "cluster_cutoff_intensity = 0			# median intensity cutoff across samples\n";
close (PARAMS);

######################################################################
## Validation of known targets parameter file generation (jump -v)	##
######################################################################
$paramsName = $paramsDir."/jump_v.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP validation (of known targets) parameter file (Version: $version, Date: $releaseDate)\n";
print PARAMS "# JUMPv extracts the identification/quantification results of input peptides/proteins\n";
print PARAMS "\n";
print PARAMS "# Peptides or proteins to be validated\n";
print PARAMS "# When searching for phosphopeptides, please REMOVE modification symbols such as #, %, *, etc.\n";
print PARAMS "peptide_1 = VRHDSPDPSPPR\n";
print PARAMS "peptide_2 = SSDEDATGEPK\n";
print PARAMS "#peptide_3 = VMSSLAPYNSSTSPQK\n";
print PARAMS "protein_1 = sp|Q9BRD0|BUD13_HUMAN\n";
print PARAMS "#protein_2 = tr|B2KFM4|B2KFM4_MOUSE\n";
print PARAMS "\n";
print PARAMS "# The raw quantification file generated by JUMPq\n";
print PARAMS "quan_file = /hpcf/authorized_apps/proteomics_apps/pipeline/release/version$version/SampleData/TMThhpho/quan_HH_pho_tmt10_human_jump_mod/raw_quan_HH_pho_tmt10_human_jump_mod_psm_nonzero.txt\n";
print PARAMS "\n";
print PARAMS "# Output file name\n";
print PARAMS "output = validation_quan_HH_pho_tmt10_human_jump_mod.txt\n";
close (PARAMS);

##################################################
## Localization of modification sites (jump -l)	##
##################################################

$paramsName = $paramsDir."/jump_l.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP localization parameter file (Version: $version, Date: $releaseDate)\n";
print PARAMS "# JUMPl identifies (localizes) the modification sites (e.g. phosphorylation)\n"; 
print PARAMS "\n";
print PARAMS "# Input and output settings\n";
print PARAMS "IDmod = /hpcf/authorized_apps/proteomics_apps/pipeline/release/version$version/SampleData/TMThhpho/sum_HH_pho_tmt10_human_jump_mod/IDmod.txt	# path for the input IDmod.txt file\n";
print PARAMS "Output = ID.lscore								# output file name\n";
print PARAMS "\n";
print PARAMS "# Preprocessing parameters\n";
print PARAMS "peptide_score_tolerance = 10							# tolerance for peptide localization score (percentage)\n";
print PARAMS "mass_correction = 2								# 0 = no correction, 1 = MS1-based, 2 = MS2-based, 3 = manual correction\n";                                                                          
print PARAMS "isolation_window = 1.2								# +/- (isolation_window)/2 based on MS2 isolation window (e.g. 1.2 m/z)\n";
print PARAMS "first_scan_extraction = 0							# the first scan number for search\n";
print PARAMS "last_scan_extraction = 1000000							# the last scan number for search, use a large number (e.g. 10E6) for full scans\n";
print PARAMS "MS2_deisotope = 1								# 0 = disable; 1 = enable\n";
print PARAMS "ppm = 10									# mass tolerance for MS2 decharging and deisotoping\n";
print PARAMS "ms2_consolidation = 30								# maximal number of peaks retained within each 100-Da window\n";
print PARAMS "\n";
print PARAMS "# Peptide selection and scoring options\n";
print PARAMS "ion_series = 0 1 0 0 0 0 0 1 0							# a, b, c, d, v, w, x, y and z ions, respectively\n";
print PARAMS "ion_losses_MS2 = 1 0 0 0							# 0 = disable; 1 = enable neutral loss of H2O, HPO3, H3PO4 and NH3, respectively\n"; 
print PARAMS "frag_mass_tolerance = 10							# mass tolerance for MS2 ion matching\n";
print PARAMS "frag_mass_tolerance_unit = 2							# 1 = Da; 2 = PPM;\n";
print PARAMS "\n";
print PARAMS "# Dynamic modifications\n";
print PARAMS "dynamic_M = 15.99492								# add each dynamic modification by one line, starting with dynamic_AA\n"; 
print PARAMS "dynamic_S = 79.96633\n";
print PARAMS "dynamic_T = 79.96633\n";
print PARAMS "dynamic_Y = 79.96633\n";
print PARAMS "max_modif_num = 3\n";
print PARAMS "\n";
print PARAMS "# Static Modification\n";
print PARAMS "add_Nterm_peptide = 229.1629321							# TMT modification or other amine labeling\n";
print PARAMS "add_Cterm_peptide = 0.0000\n";
print PARAMS "add_A_Alanine = 0.0000\n";
print PARAMS "add_B_avg_NandD = 0.0000\n";
print PARAMS "add_C_Cysteine = 57.02146								# Cys alkylation\n";
print PARAMS "add_D_Aspartic_Acid = 0.0000\n";
print PARAMS "add_E_Glutamic_Acid = 0.0000\n";
print PARAMS "add_F_Phenylalanine = 0.0000\n";
print PARAMS "add_G_Glycine = 0.0000\n";
print PARAMS "add_H_Histidine = 0.0000\n";
print PARAMS "add_I_Isoleucine = 0.0000\n";
print PARAMS "add_J_user_amino_acid = 0.0000\n";
print PARAMS "add_K_Lysine = 229.1629321							# TMT modification or other amine labeling\n";
print PARAMS "add_L_Leucine = 0.0000\n";
print PARAMS "add_M_Methionine = 0.0000\n";
print PARAMS "add_N_Asparagine = 0.0000\n";
print PARAMS "add_O_Ornithine = 0.0000\n";
print PARAMS "add_P_Proline = 0.0000\n";
print PARAMS "add_Q_Glutamine = 0.0000\n";
print PARAMS "add_R_Arginine = 0.0000\n";
print PARAMS "add_S_Serine = 0.0000\n";
print PARAMS "add_T_Threonine = 0.0000\n";
print PARAMS "add_U_user_amino_acid = 0.0000\n";
print PARAMS "add_V_Valine = 0.0000\n";
print PARAMS "add_W_Tryptophan = 0.0000\n";
print PARAMS "add_X_LorI = 0.0000\n";
print PARAMS "add_Y_Tyrosine = 0.0000\n";
print PARAMS "add_Z_avg_QandE = 0.0000\n";
print PARAMS "\n";
print PARAMS "# Other parameters\n";
print PARAMS "cluster = 1											# 0 = disable; 1 = enable; using master node only or entire cluster\n";
close (PARAMS);

my $mxmlPath   = getcwd();
my @cmd = ("python $Bin/comet_params_v3.py $mxmlPath");
#print "$mxmlPath";
system(@cmd);



#-------------------------------------------------
# the above part is copied from jump_params
#-------------------------------------------------

# $Bin = '/hpcf/authorized_apps/proteomics_apps/pipeline/release/version1.13.003/JUMP/bin'
my $cwd_dir = getcwd();# datapath
my $paramDir = $cwd_dir."/ParameterFiles";
if (!-e $paramDir) {
	system ("mkdir $paramDir");
}
my $batchDir = $paramDir."/Batch";
if (!-e $batchDir) {
	system ("mkdir $batchDir");
}

##################################################
## batch ID (jump -batch-id)	##
##################################################
$paramsName = $batchDir."/jump_batchID.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# Inputs: absolute path of publication tables from JUMP -f results (IDwDecoy.txt)\n";
print PARAMS "input_path_batch1 = /hpcf/authorized_apps/proteomics_apps/pipeline/release/SampleData/batch_test/b1/sum_HH_tmt/IDwDecoy.txt\n";
print PARAMS "input_path_batch2 = /hpcf/authorized_apps/proteomics_apps/pipeline/release/SampleData/batch_test/b2/sum_HH_tmt/IDwDecoy.txt\n";
print PARAMS "\n";
print PARAMS "# thresholds:\n";
print PARAMS "min_Jscore = 10			# minimum Jscore cutoff to be considered (10 for JUMP; 1 for Comet)\n";
print PARAMS "multiHit_max_dJn = 0.1		# for considering non-top hits for a PSM: PSMs within such dJn range will be considered in a recursive way\n";
print PARAMS "\n";
print PARAMS "enable_group_specific_Jscore = 1	# enable group specific Jscore filtering. each group defined by charge states and peptide length\n";
print PARAMS "score_cutoff_quantile = 0	# Jscore threshold for each group, defined as the lower quantile (default 5%) of Jscores in each group defined by charge states and peptide length\n";
print PARAMS "\n";
print PARAMS "# modifications\n";
print PARAMS "mods = 0			# Display modified peptides and their unmodified (0:Off, K:Lys, STY: Phosphorylation, ...); same as -f\n";
print PARAMS "#mods = STY			# Display modified peptides and their unmodified (0:Off, K:Lys, STY: Phosphorylation, ...); same as -f\n";
print PARAMS "\n";
print PARAMS "# Output:\n";
print PARAMS "output_folder = batch_id		# output folder name\n";
print PARAMS "\n";
print PARAMS "# other parameters:\n";
print PARAMS "jump_f_path = 0	# abosolte path of -f; if not specified or 0, the command of 'jump -f' will be used\n";
print PARAMS "# (in JUMP, pit_file = 0; in Comet, set pit_file according to search)\n";
print PARAMS "# pit_file = /hpcf/authorized_apps/proteomics_apps/database/20200422/HUMAN/human_ft_mc2_c57_TMT_K229.pit\n";
print PARAMS "pit_file = 0\n";
print PARAMS "database = 0\n";
print PARAMS "\n";
print PARAMS "# HPC parameters\n";
print PARAMS "dispatch = localhost\n";
close (PARAMS);

##################################################
## batch quan (jump -batch-q)	##
##################################################
$paramsName = $batchDir."/jump_batchQ.params";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "# JUMP batch correction parameter file\n";
print PARAMS "input_mode = 1					# 1: proteins (for whole proteome); 2: pho site; 3: peptides (from either phosphor- or whole proteome)\n";
print PARAMS "\n";
print PARAMS "# output path of -batch-id results\n";
print PARAMS "path_batch_id = ".$cwd_dir."/batch_id\n";
print PARAMS "\n";
print PARAMS "# ATTENTION: jump -q will run automatically for all batches using DEFAULT parameters\n";
print PARAMS "# Otherwise, User can edit filtering options within ParameterFiles/TMThh/jump_qj_HH_tmt10_human.params to customize jump -q runs\n";
print PARAMS "\n";
print PARAMS "# Specify TMT-plex for each batch (that match to jump -batch-id results)\n";
print PARAMS "input_n_batch1 = 10\n";
print PARAMS "input_n_batch2 = 10\n";
print PARAMS "\n";
print PARAMS "# Outputs:\n";
print PARAMS "output_folder = quan		# output folder suffix name; prefix always 'batch'\n";
print PARAMS "\n";
print PARAMS "# Parameters:\n";
print PARAMS "normalization_method = 1			# 0: None (i.e., just combine publication tables); 1: using internal standard; 2: using linear model fitting\n";
print PARAMS "isoform_rescue = 1				# 0: turn off; 1: turn on function. Suppose for a gene, there are two isoforms (say a and b) that are both quantified in batch 1 as demostrated by two unique peptides; but only one peptide (i.e., isoform) is quantified in batch 2. This function will copy the exact quantification of isoform a to replace the N/A for isoform b for batch 2.\n";
print PARAMS "\n";
print PARAMS "# Internal standards for each batch. The most comprehensive batch should be put first\n";
print PARAMS "internal_standard_batch1 = sig126			# internal standard for each batch\n";
print PARAMS "internal_standard_batch2 = sig126			# internal standard for each batch\n";
print PARAMS "\n";
print PARAMS "# -i parameters\n";
print PARAMS "jump_i_path = ".$Bin."/batch/jump_i.pl	# abosolte path of -i; if not specified or 0, the command of 'jump -i' will be used\n";
print PARAMS "\n";
print PARAMS "# jump -q parameters (the values here will overwrite the default values copied from the ParameterFiles/ folder above)\n";
print PARAMS "ppi_filter = 50								# precursor peak intensity percentage threshold\n";
print PARAMS "impurity_correction = 1							# 1 = Yes; 0 = No; if only a part of reporters are used, it should be set to 0\n";
print PARAMS "loading_bias_correction = 1						# 1 = Yes; 0 = No;\n";
print PARAMS "interference_removal = 0						# 1 = Yes; 0 = No;\n";
close (PARAMS);

##################################################
## steps (jump -params, -batch-id, -batch-q)	##
##################################################
$paramsName = $batchDir."/steps_batch.sh";
open (PARAMS, ">", $paramsName) or die "Cannot generate $paramsName\n";
print PARAMS "#!/bin/bash\n";
print PARAMS "\n";
print PARAMS "# step1: jump -params\n";
print PARAMS "module load jump/1.13.004\n";
print PARAMS "#jump -params\n";
print PARAMS "\n";
print PARAMS "# step2: edit batch params in WinSCP\n";
print PARAMS "# refer to: /ParameterFiles/Batch/1_User_manual_of_JUMPp_Batch\n";
print PARAMS "#jump_batchID.params\n";
print PARAMS "#jump_batchQ.params\n";
print PARAMS "\n";
print PARAMS "# step3: jump -batch-id\n";
print PARAMS "jump -batch-id jump_batchID.params\n";
print PARAMS "\n";
print PARAMS "# step4: jump -batch-q\n";
print PARAMS "jump -batch-q jump_batchQ.params\n";
close (PARAMS);

# copy $Bin/batch/user_manual to Batch path
my $cmd = "cp ".$Bin."/batch/*User_manual* ".$batchDir;
system($cmd);