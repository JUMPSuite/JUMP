.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Set::Partition 3"
.TH Set::Partition 3 "2017-11-28" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Set::Partition \- Enumerate all arrangements of a set in fixed subsets
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.03 of Set::Partition,
released 2006\-10\-11.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Set::Partition;
\&
\&  my $s = Set::Partition\->new(
\&    list      => [qw(a b c d e)],
\&    partition => [2, 3],
\&  );
\&  while (my $p = $s\->next) {
\&    print join( \*(Aq \*(Aq, map { "(@$_)" } @$p ), $/;
\&  }
\&  # produces
\&  (a b) (c d e)
\&  (a c) (b d e)
\&  (a d) (b c e)
\&  (a e) (b c d)
\&  (b c) (a d e)
\&  (b d) (a c e)
\&  (b e) (a c d)
\&  (c d) (a b e)
\&  (c e) (a b d)
\&  (d e) (a b c)
\&
\&  # or with a hash
\&  my $s = Set::Partition\->new(
\&    list      => { b => \*(Aqbat\*(Aq, c => \*(Aqcat\*(Aq, d => \*(Aqdog\*(Aq },
\&    partition => [2, 1],
\&  );
\&  while (my $p = $s\->next) {
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Set::Partition\*(C'\fR takes a list or hash of elements  and a list
numbers that represent the sizes of the partitions into which the
list of elements should be arranged.
.PP
The resulting object can then be used as an iterator which returns
a reference to an array of lists, that represents the original list
arranged according to the given partitioning. All possible arrangements
are returned, and the object returns \f(CW\*(C`undef\*(C'\fR when the entire
combination space has been exhausted.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 8
.IX Item "new"
Creates a new \f(CW\*(C`Set::Partition\*(C'\fR object. A set of key/value parameters
can be supplied to control the finer details of the object's
behaviour.
.Sp
\&\fBlist\fR, the list of elements in the set.
.Sp
\&\fBpartition\fR, the list of integers representing the size of the
partitions used to arrange the set. The sum should be equal to the
number of elements given by \fBlist\fR. If it less than the number of
elements, a dummy partition will be added to equalise the count.
This partition will be returned during iteration. If the sum is
greater than the number of elements, \f(CW\*(C`new()\*(C'\fR will \f(CW\*(C`croak\*(C'\fR with a
fatal error.
.IP "next" 8
.IX Item "next"
Returns the next arrangement of subsets, or \f(CW\*(C`undef\*(C'\fR when all arrangements
have been enumerated.
.IP "reset" 8
.IX Item "reset"
Resets the object, which causes it to enumerate the arrangements from the
beginning.
.Sp
.Vb 1
\&  $p\->reset; # begin again
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.SS "sum of partitions (%d) exceeds available elements (%d)"
.IX Subsection "sum of partitions (%d) exceeds available elements (%d)"
A list of partition sizes (for instance, 2, 3, 4) was given, along
with a list to partition (for instance, containing 8 elements),
however, the number of elements required to fill the different
partitions (9) exceeds the number available in the source list (8).
.SH "NOTES"
.IX Header "NOTES"
The order within a set is unimportant, thus, if
.PP
.Vb 1
\&  (a b) (c d)
.Ve
.PP
is produced, then the following arrangement will never be encountered:
.PP
.Vb 1
\&  (a b) (d c)
.Ve
.PP
On the other hand, the order of the sets is important, which means
that the following arrangement \fIwill\fR be encountered:
.PP
.Vb 1
\&  (c d) (a b)
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Algorithm::Combinatorics" 8
.IX Item "Algorithm::Combinatorics"
Permutations, combinations, derangements and more; all you need
for your set transformations.
.SH "BUGS"
.IX Header "BUGS"
Using a partition of length 0 is valid, although you get back an \f(CW\*(C`undef\*(C'\fR,
rather than an empty array. This could be construed as a bug.
.PP
Please report all bugs at
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Set\-Partition|rt.cpan.org>
.PP
Make sure you include the output from the following two commands:
.PP
.Vb 2
\&  perl \-MSet::Partition \-le \*(Aqprint Set::Partition::VERSION\*(Aq
\&  perl \-V
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Ken Williams suggested the possibility to use a hash as a source
for partitioning.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Landgren, copyright (C) 2006. All rights reserved.
.PP
http://www.landgren.net/perl/
.PP
If you (find a) use this module, I'd love to hear about it. If you
want to be informed of updates, send me a note. You know my first
name, you know my domain. Can you guess my e\-mail address?
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
