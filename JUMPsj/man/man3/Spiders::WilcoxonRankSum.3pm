.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Spiders::WilcoxonRankSum 3"
.TH Spiders::WilcoxonRankSum 3 "2017-11-28" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Statistics::Test::WilcoxonRankSum \- perform the Wilcoxon (aka Mann\-Whitney) rank sum test on two sets of numeric data.
.SH "VERSION"
.IX Header "VERSION"
This document describes Statistics::Test::WilcoxonRankSum version 0.0.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Statistics::Test::WilcoxonRankSum;
\&
\&    my $wilcox_test = Statistics::Test::WilcoxonRankSum\->new();
\&
\&    my @dataset_1 = (4.6, 4.7, 4.9, 5.1, 5.2, 5.5, 5.8, 6.1, 6.5, 6.5, 7.2);
\&    my @dataset_2 = (5.2, 5.3, 5.4, 5.6, 6.2, 6.3, 6.8, 7.7, 8.0, 8.1);
\&
\&    $wilcox_test\->load_data(\e@dataset_1, \e@dataset_2);
\&    my $prob = $wilcox_test\->probability();
\&
\&    my $pf = sprintf \*(Aq%f\*(Aq, $prob; # prints 0.091022
\&
\&    print $wilcox_test\->probability_status();
\&
\&    # prints something like:
\&    # Probability:   0.002797, exact
\&    # or
\&    # Probability:   0.511020, normal approx w. mean: 104.000000, std deviation:  41.840969, z:   0.657251
\&
\&    my $pstatus = $wilcox_test\->probability_status();
\&    # $pstatus is like the strings above
\&
\&    $wilcox_test\->summary();
\&
\&    # prints something like:
\&
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    # dataset |    n      | rank sum: observed / expected 
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    #   1    |     10    |               533      /    300
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    #   2    |     50    |              1296      /   1500
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    # N (size of both datasets):      60
\&    # Probability:   0.000006, normal approx w. mean: 305.000000, std deviation:  50.414945, z:   4.522468
\&    # Significant (at 0.05 level)
\&    # Ranks of dataset 1 are higher than expected
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In statistics, the Mann-Whitney U test (also called the Mann-Whitney-Wilcoxon (\s-1MWW\s0), Wilcoxon rank-sum test, or Wilcoxon-Mann-Whitney test) is a non-parametric test for assessing whether two samples of observations come from the same distribution. The null hypothesis is that the two samples are drawn from a single population, and therefore that their probability distributions are equal. See the Wikipedia entry <http://en.wikipedia.org/wiki/Mann\-Whitney_U> (for eg.) or statistic textbooks for further details.
.PP
When the sample sizes are small the probability can be computed directly. For larger samples usually a normal approximation is used.
.SS "The Mechanics"
.IX Subsection "The Mechanics"
Input to the test are two sets (lists) of numbers. The values of both lists are ranked from the smallest to the largest, while remembering which set the items come from. When the values are the same, they get an average rank. For each of the sample sets, we compute the rank sum. Under the assumption that the two samples come from the same population, the rank sum of the first set should be close to the value \fBn1 * (n1 + n2 + 1)/2\fR, where n1 and n2 are the sample sizes. The test computes the (exact, resp. approximated) probability of the actual rank sum against the expected value (which is the one given above). So, when the computed probability is below \fI0.05\fR, we can reject the null hypothesis at level 0.05 and conclude that the two samples are significantly different.
.SS "Implementation"
.IX Subsection "Implementation"
The implementation follows the mechanics described above. The exact probability is computed for sample sizes less than \fB20\fR, but this threshold can be set with `new'. For larger samples the probability is computed by normal approximation.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "Constructor"
.IX Subsection "Constructor"
.IP "\fInew()\fR" 4
.IX Item "new()"
Builds a new Statistics::Test::WilcoxonRankSum object.
.Sp
When called like this:
.Sp
.Vb 1
\& Statistics::Test::WilcoxonRankSum\->new( { exact_upto => 30 }
.Ve
.Sp
the exact probability will be computed for sample sizes lower than 30 (instead of 20, which is the default).
.SS "Providing the Data"
.IX Subsection "Providing the Data"
.IP "load_data(\e@dataset_1, \e@dataset_2)" 4
.IX Item "load_data(@dataset_1, @dataset_2)"
.PD 0
.IP "set_dataset1(\e@dataset_1)" 4
.IX Item "set_dataset1(@dataset_1)"
.IP "set_dataset2(\e@dataset_2)" 4
.IX Item "set_dataset2(@dataset_2)"
.PD
.PP
When calling these methods, all previously computed rank sums and probabilities are reset.
.SS "Computations"
.IX Subsection "Computations"
\fIRanks\fR
.IX Subsection "Ranks"
.IP "\fIcompute_ranks()\fR" 4
.IX Item "compute_ranks()"
The two datasets are put together and ranked (taking care of ties). The method returns a hash reference to a hash, with the data values as keys, looking like this:
.Sp
.Vb 10
\&                      \*(Aq3\*(Aq => {
\&                              \*(Aqtied\*(Aq => 2,
\&                              \*(Aqin_dataset\*(Aq => {
\&                                               \*(Aqds2\*(Aq => 2
\&                                              },
\&                              \*(Aqrank\*(Aq => \*(Aq1.5\*(Aq
\&                             },
\&                      \*(Aq24\*(Aq => {
\&                               \*(Aqtied\*(Aq => 1,
\&                               \*(Aqin_dataset\*(Aq => {
\&                                                \*(Aqds1\*(Aq => 1
\&                                               },
\&                               \*(Aqrank\*(Aq => \*(Aq7\*(Aq
\&                              },
.Ve
.IP "compute_rank_array" 4
.IX Item "compute_rank_array"
Returns the ranks computed above in a differen form (depending on the context, an array of or the reference to array references):
.Sp
.Vb 1
\& [ [ \*(Aq1.5\*(Aq, \*(Aqds2\*(Aq ], [ \*(Aq1.5\*(Aq, \*(Aqds2\*(Aq ], [ \*(Aq3\*(Aq, \*(Aqds1\*(Aq ], ...]
.Ve
.Sp
The first item in the second level arrays is the rank and the second marks the data set the ranked item came from.
\&\fIds1\fR \-\-> first dataset, \fIds2\fR \-\-> second dataset.
.Sp
In scalar context returns the number of elements (ie. the size of the two samples).
.IP "rank_sum_for" 4
.IX Item "rank_sum_for"
Computes rank sum for dataset given as argument. If the argument matches \fI1\fR, this will be dataset 1, else dataset 2.
.IP "get_smaller_rank_sum" 4
.IX Item "get_smaller_rank_sum"
Checks which of the two rank sums is the smaller one.
.IP "smaller_rank_sums_count" 4
.IX Item "smaller_rank_sums_count"
For the set with the smaller rank sum, counts the number of partitions (of the ranks) giving a smaller rank sum than the observed one. Needed to compute the exact probability.
.IP "rank_sums_other_than_expected_counts" 4
.IX Item "rank_sums_other_than_expected_counts"
For the set with the smaller rank sum, counts the number of partitions (of the ranks) giving a rank sum other than the observed one (For example if the rank sum is larger than expected, counts the number of partitions giving a rank sum larger than the observed one). Needed to compute the exact probability.
.PP
\fIProbabilities\fR
.IX Subsection "Probabilities"
.IP "probability" 4
.IX Item "probability"
Computes (and returns) the probability of the given outcome under the assumption that the two data samples come from the same population. When the size of the two samples taken together is less than \fIexact_upto\fR, \*(L"probability_exact\*(R" is called, else \*(L"probability_normal_approx\*(R". The parameter \fIexact_upto\fR can be passed to \*(L"new\*(R" as argument and defaults to \fI20\fR.
.Sp
When the size of the two samples taken together is less than 5, it makes not much sense to compute the probability. Currently, only the \*(L"summary\*(R" method issues a warning.
.Sp
This method is also called whenever an object of this class needs to be coerced to a number.
.IP "probability_exact" 4
.IX Item "probability_exact"
Compute the probability by counting.
.IP "probability_normal_approx" 4
.IX Item "probability_normal_approx"
Compute the probability by normal approximation.
.SS "Display and Notification"
.IX Subsection "Display and Notification"
.IP "probability_status" 4
.IX Item "probability_status"
Tells if the probability has been or can be computed. If it has been computed shows the value and how it has been computed (by the direct method or by normal approximation).
.IP "summary" 4
.IX Item "summary"
Prints or returns a string with diagnostics like this:
.Sp
.Vb 11
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    # dataset |    n      | rank sum: observed / expected 
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    #   1    |     10    |               533      /    300
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    #   2    |     50    |              1296      /   1500
\&    # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    # N (size of both datasets):      60
\&    # Probability:   0.000006, normal approx w. mean: 305.000000, std deviation:  50.414945, z:   4.522468
\&    # Significant (at 0.05 level)
\&    # Ranks of dataset 1 are higher than expected
.Ve
.Sp
This method also issues a warning, when the size of the 2 samples taken together is less than 5.
.Sp
\&\fBsummary\fR is called whenever an object of this class needs to be coerced to a string.
.IP "as_hash" 4
.IX Item "as_hash"
Returns a hash reference with the gathered data, needed to compute the probabilities, with the following keys:
.RS 4
.IP "dataset_1" 4
.IX Item "dataset_1"
The first dataset (array ref)
.IP "dataset_2" 4
.IX Item "dataset_2"
The second dataset (also array ref)
.IP "n1" 4
.IX Item "n1"
size of first dataset
.IP "n2" 4
.IX Item "n2"
size of second dataset
.IP "N" 4
.IX Item "N"
.Vb 1
\& n1 + n2
.Ve
.IP "rank_array" 4
.IX Item "rank_array"
the array returned by \*(L"compute_rank_array\*(R", see there.
.IP "rank_sum_1, rank_sum_2" 4
.IX Item "rank_sum_1, rank_sum_2"
rank sum of first and second dataset respectively.
.IP "rank_sum_1_expected rank_sum_2_expected" 4
.IX Item "rank_sum_1_expected rank_sum_2_expected"
the expected rank sums, if the two samples came from the same population. For the first dataset this is:
.Sp
.Vb 1
\&  n1 * (N+1) / 2
.Ve
.IP "probability" 4
.IX Item "probability"
.PD 0
.IP "probability_normal_approx" 4
.IX Item "probability_normal_approx"
.PD
data used for computing the probability by normal approximation, when the sample size is too large. A hash reference with the following keys: \fBmean\fR, \fBstd deviation\fR, \fBz\fR.
.RE
.RS 4
.RE
.SS "Getter"
.IX Subsection "Getter"
The following methods are provided by the \fIClass::Std\fR \fI:get\fR facility and return the corresponding object data:
.IP "get_dataset1, get_dataset2" 4
.IX Item "get_dataset1, get_dataset2"
.PD 0
.IP "get_n1" 4
.IX Item "get_n1"
.IP "get_n2" 4
.IX Item "get_n2"
.IP "get_N" 4
.IX Item "get_N"
.IP "get_max_rank_sum" 4
.IX Item "get_max_rank_sum"
.IP "get_rank_array" 4
.IX Item "get_rank_array"
.IP "get_rankSum_dataset1, get_rankSum_dataset2" 4
.IX Item "get_rankSum_dataset1, get_rankSum_dataset2"
.IP "expected_rank_sum_dataset1, expected_rank_sum_dataset2" 4
.IX Item "expected_rank_sum_dataset1, expected_rank_sum_dataset2"
.PD
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Need array ref to dataset""" 4
.el .IP "\f(CWNeed array ref to dataset\fR" 4
.IX Item "Need array ref to dataset"
.PD 0
.ie n .IP """Datasets must be passed as array references""" 4
.el .IP "\f(CWDatasets must be passed as array references\fR" 4
.IX Item "Datasets must be passed as array references"
.PD
When a \*(L"Providing the Data\*(R" method is called without enough arguments, or when the arguments are not array references.
.ie n .IP """dataset has no element greater 0""" 4
.el .IP "\f(CWdataset has no element greater 0\fR" 4
.IX Item "dataset has no element greater 0"
It makes no sense to compute the probability when all the items are 0.
.ie n .IP """Please set/load datasets before computing ranks""" 4
.el .IP "\f(CWPlease set/load datasets before computing ranks\fR" 4
.IX Item "Please set/load datasets before computing ranks"
Maybe you called a \*(L"compute_ranks\*(R" method, and didn't hand in both datasets?
.ie n .IP """Argument must match \`1\*(Aq or \`2\*(Aq (meaning dataset 1 or 2)""" 4
.el .IP "\f(CWArgument must match \`1\*(Aq or \`2\*(Aq (meaning dataset 1 or 2)\fR" 4
.IX Item "Argument must match 1 or 2 (meaning dataset 1 or 2)"
The method \*(L"rank_sum_for\*(R" must know what dataset to compute the rank for: dataset 1, if the argument matches 1, dataset 2 if the argument matches 2.
.ie n .IP """Rank sum bound %i is bigger than the maximum possible rank sum %i""" 4
.el .IP "\f(CWRank sum bound %i is bigger than the maximum possible rank sum %i\fR" 4
.IX Item "Rank sum bound %i is bigger than the maximum possible rank sum %i"
.PD 0
.ie n .IP """Sum of %i and %i must be equal to number of ranks: %i""" 4
.el .IP "\f(CWSum of %i and %i must be equal to number of ranks: %i\fR" 4
.IX Item "Sum of %i and %i must be equal to number of ranks: %i"
.PD
Plausibility checks before doing the rank sum counts (\*(L"smaller_rank_sums_count\*(R"). Something's terribly broken when this occurs.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Statistics::Test::WilcoxonRankSum requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.IP "Carp" 4
.IX Item "Carp"
.PD 0
.IP "Carp::Assert" 4
.IX Item "Carp::Assert"
.IP "Class::Std" 4
.IX Item "Class::Std"
.IP "Contextual::Return" 4
.IX Item "Contextual::Return"
.IP "Set::Partition" 4
.IX Item "Set::Partition"
.IP "List::Util qw(sum)" 4
.IX Item "List::Util qw(sum)"
.IP "Math::BigFloat" 4
.IX Item "Math::BigFloat"
.IP "Math::Counting" 4
.IX Item "Math::Counting"
.IP "Statistics::Distributions" 4
.IX Item "Statistics::Distributions"
